---
title: "CRQA Final Results"
author: "Adam Stone, PhD"
date: '`r format(Sys.Date(), "%m-%d-%Y")`'
output:
  html_notebook:
    code_folding: hide
    highlight: tango
    theme: yeti
    toc: yes
    toc_depth: 2
---

```{r Load Libraries, message=FALSE, warning=FALSE}
# Load libraries
library(tidyverse)
library(janitor)
library(lme4)
library(broom)
library(broom.mixed)
library(sjPlot)
library(assertr)
library(skimr)
library(hrbrthemes)
```


OK! After messy code in 12_, 13_, and 14_ (should clean it up, eek), we have CRQA results all over. Cool. Let's load 'em all and smoosh up all the input data and output variables in one neat data frame. 

```{r Loading & Tidying Data, message=FALSE, warning=FALSE}

# This are the data frames (with lists, etc.) used for finding the optimal
# radius for each person's eye gaze, against both the right hand and the left
# hand. First, we took all data associated with each story x direction x hand,
# and found the optimal embeddim and delay parameters for each via the
# optimizeParam() function. Then we ran those optimal parameters in CRQAs with a
# radius range of 5-60 ("test radius") to get associated rr_values. The target
# rr_value was 5, and the test radius that produced the target rr_value was then
# used for the final CRQA.
crqa_inputdata_r <- readRDS("crqa_rhand.RDS") %>%
  add_column(hand = "right") %>%
  rename(hand_y = rhand_y,
         hand_len = rhand_len,
         radius = test_radius)
  
crqa_inputdata_l <- readRDS("crqa_lhand.RDS") %>%
  add_column(hand = "left") %>%
  rename(hand_y = lhand_y,
         hand_len = lhand_len,
         radius = test_radius)

input_data <- bind_rows(crqa_inputdata_r,
                        crqa_inputdata_l)

rm('crqa_inputdata_r')
rm('crqa_inputdata_l')


# These are the CRQA results for each participant x story x direction x hand,
# using the test radius found above.
crqa_results_r <- read_csv("crqa_results_rhand.csv") %>%
  add_column(hand = "right") %>%
  rename_at(vars(rhand_rr:rhand_tt), ~ str_remove(.x, "rhand_")) %>%
  rename(radius = optimized_r)

crqa_results_l <- read_csv("crqa_results_lhand.csv") %>%
  add_column(hand = "left") %>%
  rename_at(vars(lhand_rr:lhand_tt), ~ str_remove(.x, "lhand_")) %>%
  rename(radius = optimized_r)

results <- bind_rows(crqa_results_r,
                     crqa_results_l)

rm('crqa_results_r')
rm('crqa_results_l')

# Now combine everything in one neat data frame
final <- results %>%
  left_join(input_data, by = c("name",
                               "maingroup",
                               "story",
                               "direction",
                               "embeddim",
                               "delay",
                               "radius",
                               "hand")) %>%
  verify(rr == rr_values) %>%
  mutate_at(vars(name, maingroup, story, direction, hand), as.factor) %>%
  select(-rr_values)

rm('results')
rm('input_data')

# Print summaries
skim_with(numeric = list(p25 = NULL,
                         p75 = NULL),
          integer = list(p25 = NULL,
                         p75 = NULL))
skim(final)
```

# Radius Values

Because we fixed the %REC (`RR`) to 5.0, that means the radius varies for each row. See below:

> If the data sets cannot be reasonably fitted with a single radius parameter...one can adjust the radius for each data set individually in order to keep the percentage of recurrence constant across all data sets (e.g., fixed percent recurrence of %REC = 5% for each data set). Of course, in this case, %REC needs to be omitted from the inferential statistical analysis, as it should be very similar (or the same) across pairings in all samples, but the other measures, such as %DET, ADL, and MDL can be still analyzed (as a stand-in for %REC, one can instead include analysis of the radius parameter r that is now different across pairs of groups of time-series. However, this might not yield the same results, as r and %REC do not scale linearly with each other).

So we can use radius as an outcome variable. What does radius mean? 

> The radius parameter r effectively specifies the interval within which two values are counted as being recurrent. 

So in other words, if we kept %REC = 5.0, that forces the radius to vary so that 5.0% of all possible points show recurrence. If the radius is high, that means the two time-series were "farther apart" and the higher radius was necessary in order to bring those two time-series into 5.0% recurrence. Conversely, a low radius indicates the two time-series do share more recurrence and thus a tighter radius still achieved 5.0% recurrence. 

Let's model that!

* Predictors: maingroup & direction
* Grouping variables (random intercepts): name & story
* Random slopes: hand (for name...so for each participant we allow the slope to vary for right vs. left)

It's actually a good thing we have CRQA results for both left and right hands. We know there is not a world of a difference between them, so we can "double" the dataset by adding "hand" as a random effects variable! 

```{r message=FALSE, warning=FALSE}

# Plot means
final_n <- final %>%
  select(name, maingroup, direction, story, hand) %>%
  distinct() %>%
  count(maingroup, direction, hand)

final_summary <- final %>%
  group_by(maingroup, direction, hand) %>%
  summarise(radius_mean = mean(radius),
            radius_sd = sd(radius)) %>%
  ungroup() %>%
  left_join(final_n, by = c("maingroup", "direction", "hand")) %>%
  mutate(radius_se = radius_sd/sqrt(n))
  
final_summary %>%
  filter(hand == "right") %>%
  ggplot(aes(x = maingroup, y = radius_mean, color = direction, fill = direction)) +
  geom_point(position = position_dodge(width = 0.25), size = 2) +
  geom_errorbar(aes(ymin = radius_mean - radius_se, ymax = radius_mean + radius_se),
                position = position_dodge(width = 0.25),
                width = 0.2,
                size = 1) +
  scale_y_continuous(limits = c(20, 37)) +
  labs(x = "",
       y = "radius",
       title = "Radius Values for 5.0% Recurrence With Right Hand Position") +
  theme_light()

# Fit model
m1 <- lmer(data = final, radius ~ maingroup * direction + (1 + hand|name) + (1|story))
tidy(m1, conf.int = TRUE) %>%
  mutate_if(is.numeric, round, 2) %>%
  filter(effect == 'fixed') %>%
  select(-effect, -group)

# Plot model coefficients
# https://cran.r-project.org/web/packages/sjPlot/vignettes/plot_model_estimates.html
plot_model(m1, 
           show.values = TRUE, value.offset = .3, 
           order.terms = c(4, 1:3, 5:7),
           width = .2,
           dot.size = 1,
           title = "Model Predictors for Radius (95% CI)")
```

The interpretation is :  

1. We have a main effect of direction. RV results in smaller radius values, which means *more tightly coupled* viewing. Reversing video makes people pay more attention to the hands. 
1. There is no main effect of MainGroup...although Hearing Novice gets close. 
1. We have an interaction of Maingroup & Direction, where Hearing Noivce, when confronted w reverse video, become *less coupled* to hand position. It's possible they dis-engage and engage in poorer viewing behavior in general!


# Time-Series Plot

We need a plot like this for the poster, to give people an idea of what we are talking about. This was submitted with the abstract as figure 2. Re-creating it here. 

```{r}

averaged_y <- read_csv("bears_time_series_group_averages.csv")

averaged_y %>%
  ggplot() + 
  geom_line(aes(x = gaze_point_index, y = y_mean, color = maingroup), size = 0.8) +
  geom_ribbon(aes(x = gaze_point_index, 
                  ymin = y_mean-y_se, 
                  ymax = y_mean+y_se,
                  fill = maingroup), alpha = 0.5) +
  scale_y_reverse(limits = c(1200,0)) +
  facet_wrap("maingroup") +
  labs(x = "time (ms)", y = "pixels", title = "Figure 1. Vertical Eye Gaze Position Across One ASL Narrative") +
  guides(color = F, fill = F) +
  theme_ipsum_rc()

averaged_y %>%
  ggplot() + 
  geom_line(aes(x = gaze_point_index, y = y_mean, color = maingroup)) +
  geom_ribbon(aes(x = gaze_point_index, 
                  ymin = y_mean-y_se, 
                  ymax = y_mean+y_se,
                  fill = maingroup), alpha = 0.5) +
  scale_y_reverse(limits = c(1200,0)) +
  theme_bw()

averaged_y %>%
  filter(maingroup == "DeafEarly" | maingroup == "HearingNovice") %>%
  ggplot() + 
  geom_line(aes(x = gaze_point_index, y = y_mean, color = maingroup), size = 0.8) +
  geom_ribbon(aes(x = gaze_point_index, 
                  ymin = y_mean-y_se, 
                  ymax = y_mean+y_se,
                  fill = maingroup), alpha = 0.1) +
  scale_y_reverse(limits = c(700,300)) +
  labs(x = "time (ms)", y = "pixels", title = "Figure 2. Deaf Early Signers vs. Hearing Novice Signers", color = "", fill = "") +
  theme_ipsum_rc()
```

